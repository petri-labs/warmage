// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: warmage/maker/v1/maker.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BackingRiskParams represents an object of backing coin risk parameters.
type BackingRiskParams struct {
	// backing coin denom
	BackingDenom string `protobuf:"bytes,1,opt,name=backing_denom,json=backingDenom,proto3" json:"backing_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total backing amount
	MaxBacking *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=max_backing,json=maxBacking,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_backing,omitempty"`
	// maximum mintable War amount
	MaxWarMint *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=max_war_mint,json=maxWarMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_war_mint,omitempty"`
	// mint fee rate
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// burn fee rate
	BurnFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=burn_fee,json=burnFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_fee,omitempty"`
	// buyback fee rate
	BuybackFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=buyback_fee,json=buybackFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"buyback_fee,omitempty"`
	// reback fee rate
	RebackFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=reback_fee,json=rebackFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"reback_fee,omitempty"`
}

func (m *BackingRiskParams) Reset()         { *m = BackingRiskParams{} }
func (m *BackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*BackingRiskParams) ProtoMessage()    {}
func (*BackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{0}
}
func (m *BackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackingRiskParams.Merge(m, src)
}
func (m *BackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BackingRiskParams proto.InternalMessageInfo

func (m *BackingRiskParams) GetBackingDenom() string {
	if m != nil {
		return m.BackingDenom
	}
	return ""
}

func (m *BackingRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// CollateralRiskParams represents an object of collateral risk parameters.
type CollateralRiskParams struct {
	// collateral coin denom
	CollateralDenom string `protobuf:"bytes,1,opt,name=collateral_denom,json=collateralDenom,proto3" json:"collateral_denom,omitempty"`
	// whether enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// maximum total collateral amount; empty means no limit
	MaxCollateral *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=max_collateral,json=maxCollateral,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_collateral,omitempty"`
	// maximum total mintable War amount; empty means no limit
	MaxWarMint *github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=max_war_mint,json=maxWarMint,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_war_mint,omitempty"`
	// ratio at which a position is defined as undercollateralized
	LiquidationThreshold *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=liquidation_threshold,json=liquidationThreshold,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_threshold,omitempty"`
	// maximum ratio of maximum amount of currency that can be borrowed with a
	// specific collateral
	LoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=loan_to_value,json=loanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"loan_to_value,omitempty"`
	// basic ratio of maximum amount of currency that can be borrowed with a
	// specific collateral
	BasicLoanToValue *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=basic_loan_to_value,json=basicLoanToValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"basic_loan_to_value,omitempty"`
	// catalytic ratio of collateralized Mage to asset, to maximize the LTV
	// in [basic-LTV, LTV]
	CatalyticMageRatio *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,8,opt,name=catalytic_mage_ratio,json=catalyticMageRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"catalytic_mage_ratio,omitempty"`
	// liquidation fee rate, i.e., the discount a liquidator gets when buying
	// collateral flagged for a liquidation
	LiquidationFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,9,opt,name=liquidation_fee,json=liquidationFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidation_fee,omitempty"`
	// mint fee rate, i.e., extra fee debt
	MintFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,10,opt,name=mint_fee,json=mintFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"mint_fee,omitempty"`
	// annual interest fee rate (APR)
	InterestFee *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,11,opt,name=interest_fee,json=interestFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"interest_fee,omitempty"`
}

func (m *CollateralRiskParams) Reset()         { *m = CollateralRiskParams{} }
func (m *CollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*CollateralRiskParams) ProtoMessage()    {}
func (*CollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{1}
}
func (m *CollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CollateralRiskParams.Merge(m, src)
}
func (m *CollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *CollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_CollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_CollateralRiskParams proto.InternalMessageInfo

func (m *CollateralRiskParams) GetCollateralDenom() string {
	if m != nil {
		return m.CollateralDenom
	}
	return ""
}

func (m *CollateralRiskParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// RegisterBackingProposal is a gov Content type to register eligible
// strong-backing asset with backing risk parameters.
type RegisterBackingProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *RegisterBackingProposal) Reset()         { *m = RegisterBackingProposal{} }
func (m *RegisterBackingProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterBackingProposal) ProtoMessage()    {}
func (*RegisterBackingProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{2}
}
func (m *RegisterBackingProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterBackingProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterBackingProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterBackingProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterBackingProposal.Merge(m, src)
}
func (m *RegisterBackingProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterBackingProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterBackingProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterBackingProposal proto.InternalMessageInfo

func (m *RegisterBackingProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterBackingProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterBackingProposal) GetRiskParams() BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return BackingRiskParams{}
}

// RegisterCollateralProposal is a gov Content type to register eligible
// collateral with collateral risk parameters.
type RegisterCollateralProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *RegisterCollateralProposal) Reset()         { *m = RegisterCollateralProposal{} }
func (m *RegisterCollateralProposal) String() string { return proto.CompactTextString(m) }
func (*RegisterCollateralProposal) ProtoMessage()    {}
func (*RegisterCollateralProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{3}
}
func (m *RegisterCollateralProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterCollateralProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterCollateralProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterCollateralProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterCollateralProposal.Merge(m, src)
}
func (m *RegisterCollateralProposal) XXX_Size() int {
	return m.Size()
}
func (m *RegisterCollateralProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterCollateralProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterCollateralProposal proto.InternalMessageInfo

func (m *RegisterCollateralProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RegisterCollateralProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RegisterCollateralProposal) GetRiskParams() CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return CollateralRiskParams{}
}

// SetBackingRiskParamsProposal is a gov Content type to set backing coin risk
// parameters.
type SetBackingRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// backing risk params
	RiskParams BackingRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *SetBackingRiskParamsProposal) Reset()         { *m = SetBackingRiskParamsProposal{} }
func (m *SetBackingRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*SetBackingRiskParamsProposal) ProtoMessage()    {}
func (*SetBackingRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{4}
}
func (m *SetBackingRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBackingRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBackingRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetBackingRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBackingRiskParamsProposal.Merge(m, src)
}
func (m *SetBackingRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetBackingRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBackingRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetBackingRiskParamsProposal proto.InternalMessageInfo

func (m *SetBackingRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetBackingRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetBackingRiskParamsProposal) GetRiskParams() BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return BackingRiskParams{}
}

// SetCollateralRiskParamsProposal is a gov Content type to set collateral risk
// parameters.
type SetCollateralRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// collateral risk params
	RiskParams CollateralRiskParams `protobuf:"bytes,3,opt,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *SetCollateralRiskParamsProposal) Reset()         { *m = SetCollateralRiskParamsProposal{} }
func (m *SetCollateralRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*SetCollateralRiskParamsProposal) ProtoMessage()    {}
func (*SetCollateralRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{5}
}
func (m *SetCollateralRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetCollateralRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetCollateralRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetCollateralRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetCollateralRiskParamsProposal.Merge(m, src)
}
func (m *SetCollateralRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *SetCollateralRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_SetCollateralRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_SetCollateralRiskParamsProposal proto.InternalMessageInfo

func (m *SetCollateralRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SetCollateralRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SetCollateralRiskParamsProposal) GetRiskParams() CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return CollateralRiskParams{}
}

type BatchBackingRiskParams struct {
	// batch of collateral risk params
	RiskParams []BackingRiskParams `protobuf:"bytes,1,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchBackingRiskParams) Reset()         { *m = BatchBackingRiskParams{} }
func (m *BatchBackingRiskParams) String() string { return proto.CompactTextString(m) }
func (*BatchBackingRiskParams) ProtoMessage()    {}
func (*BatchBackingRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{6}
}
func (m *BatchBackingRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchBackingRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchBackingRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchBackingRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchBackingRiskParams.Merge(m, src)
}
func (m *BatchBackingRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BatchBackingRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchBackingRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BatchBackingRiskParams proto.InternalMessageInfo

func (m *BatchBackingRiskParams) GetRiskParams() []BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetBackingRiskParamsProposal is a gov Content type to batch set backing
// coin risk parameters.
type BatchSetBackingRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []BackingRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchSetBackingRiskParamsProposal) Reset()         { *m = BatchSetBackingRiskParamsProposal{} }
func (m *BatchSetBackingRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*BatchSetBackingRiskParamsProposal) ProtoMessage()    {}
func (*BatchSetBackingRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{7}
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetBackingRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetBackingRiskParamsProposal.Merge(m, src)
}
func (m *BatchSetBackingRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetBackingRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetBackingRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetBackingRiskParamsProposal proto.InternalMessageInfo

func (m *BatchSetBackingRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetBackingRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetBackingRiskParamsProposal) GetRiskParams() []BackingRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

type BatchCollateralRiskParams struct {
	// batch of collateral risk params
	RiskParams []CollateralRiskParams `protobuf:"bytes,1,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchCollateralRiskParams) Reset()         { *m = BatchCollateralRiskParams{} }
func (m *BatchCollateralRiskParams) String() string { return proto.CompactTextString(m) }
func (*BatchCollateralRiskParams) ProtoMessage()    {}
func (*BatchCollateralRiskParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{8}
}
func (m *BatchCollateralRiskParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchCollateralRiskParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchCollateralRiskParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchCollateralRiskParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCollateralRiskParams.Merge(m, src)
}
func (m *BatchCollateralRiskParams) XXX_Size() int {
	return m.Size()
}
func (m *BatchCollateralRiskParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCollateralRiskParams.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCollateralRiskParams proto.InternalMessageInfo

func (m *BatchCollateralRiskParams) GetRiskParams() []CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

// BatchSetCollateralRiskParamsProposal is a gov Content type to batch set
// collateral risk parameters.
type BatchSetCollateralRiskParamsProposal struct {
	// title of the proposal
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	// proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// batch of collateral risk params
	RiskParams []CollateralRiskParams `protobuf:"bytes,3,rep,name=risk_params,json=riskParams,proto3" json:"risk_params"`
}

func (m *BatchSetCollateralRiskParamsProposal) Reset()         { *m = BatchSetCollateralRiskParamsProposal{} }
func (m *BatchSetCollateralRiskParamsProposal) String() string { return proto.CompactTextString(m) }
func (*BatchSetCollateralRiskParamsProposal) ProtoMessage()    {}
func (*BatchSetCollateralRiskParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{9}
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSetCollateralRiskParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetCollateralRiskParamsProposal.Merge(m, src)
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *BatchSetCollateralRiskParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetCollateralRiskParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetCollateralRiskParamsProposal proto.InternalMessageInfo

func (m *BatchSetCollateralRiskParamsProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *BatchSetCollateralRiskParamsProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *BatchSetCollateralRiskParamsProposal) GetRiskParams() []CollateralRiskParams {
	if m != nil {
		return m.RiskParams
	}
	return nil
}

type TotalBacking struct {
	// total backing value in uUSD
	BackingValue github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=backing_value,json=backingValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"backing_value"`
	// total minted war; negative value means burned war
	WarMinted types.Coin `protobuf:"bytes,2,opt,name=war_minted,json=warMinted,proto3" json:"war_minted"`
	// total burned mage; negative value means minted mage
	MageBurned types.Coin `protobuf:"bytes,3,opt,name=mage_burned,json=mageBurned,proto3" json:"mage_burned"`
}

func (m *TotalBacking) Reset()         { *m = TotalBacking{} }
func (m *TotalBacking) String() string { return proto.CompactTextString(m) }
func (*TotalBacking) ProtoMessage()    {}
func (*TotalBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{10}
}
func (m *TotalBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalBacking.Merge(m, src)
}
func (m *TotalBacking) XXX_Size() int {
	return m.Size()
}
func (m *TotalBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalBacking.DiscardUnknown(m)
}

var xxx_messageInfo_TotalBacking proto.InternalMessageInfo

func (m *TotalBacking) GetWarMinted() types.Coin {
	if m != nil {
		return m.WarMinted
	}
	return types.Coin{}
}

func (m *TotalBacking) GetMageBurned() types.Coin {
	if m != nil {
		return m.MageBurned
	}
	return types.Coin{}
}

type PoolBacking struct {
	// total minted war; negative value means burned war
	WarMinted types.Coin `protobuf:"bytes,1,opt,name=war_minted,json=warMinted,proto3" json:"war_minted"`
	// total backing
	Backing types.Coin `protobuf:"bytes,2,opt,name=backing,proto3" json:"backing"`
	// total burned mage; negative value means minted mage
	MageBurned types.Coin `protobuf:"bytes,3,opt,name=mage_burned,json=mageBurned,proto3" json:"mage_burned"`
}

func (m *PoolBacking) Reset()         { *m = PoolBacking{} }
func (m *PoolBacking) String() string { return proto.CompactTextString(m) }
func (*PoolBacking) ProtoMessage()    {}
func (*PoolBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{11}
}
func (m *PoolBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolBacking.Merge(m, src)
}
func (m *PoolBacking) XXX_Size() int {
	return m.Size()
}
func (m *PoolBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolBacking.DiscardUnknown(m)
}

var xxx_messageInfo_PoolBacking proto.InternalMessageInfo

func (m *PoolBacking) GetWarMinted() types.Coin {
	if m != nil {
		return m.WarMinted
	}
	return types.Coin{}
}

func (m *PoolBacking) GetBacking() types.Coin {
	if m != nil {
		return m.Backing
	}
	return types.Coin{}
}

func (m *PoolBacking) GetMageBurned() types.Coin {
	if m != nil {
		return m.MageBurned
	}
	return types.Coin{}
}

type AccountBacking struct {
}

func (m *AccountBacking) Reset()         { *m = AccountBacking{} }
func (m *AccountBacking) String() string { return proto.CompactTextString(m) }
func (*AccountBacking) ProtoMessage()    {}
func (*AccountBacking) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{12}
}
func (m *AccountBacking) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountBacking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountBacking.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountBacking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountBacking.Merge(m, src)
}
func (m *AccountBacking) XXX_Size() int {
	return m.Size()
}
func (m *AccountBacking) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountBacking.DiscardUnknown(m)
}

var xxx_messageInfo_AccountBacking proto.InternalMessageInfo

type TotalCollateral struct {
	// total existing war debt, including minted by collateral, mint fee, last
	// interest
	WarDebt types.Coin `protobuf:"bytes,1,opt,name=war_debt,json=warDebt,proto3" json:"war_debt"`
	// total collateralized mage
	MageCollateralized types.Coin `protobuf:"bytes,2,opt,name=mage_collateralized,json=mageCollateralized,proto3" json:"mage_collateralized"`
}

func (m *TotalCollateral) Reset()         { *m = TotalCollateral{} }
func (m *TotalCollateral) String() string { return proto.CompactTextString(m) }
func (*TotalCollateral) ProtoMessage()    {}
func (*TotalCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{13}
}
func (m *TotalCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TotalCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TotalCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TotalCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TotalCollateral.Merge(m, src)
}
func (m *TotalCollateral) XXX_Size() int {
	return m.Size()
}
func (m *TotalCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_TotalCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_TotalCollateral proto.InternalMessageInfo

func (m *TotalCollateral) GetWarDebt() types.Coin {
	if m != nil {
		return m.WarDebt
	}
	return types.Coin{}
}

func (m *TotalCollateral) GetMageCollateralized() types.Coin {
	if m != nil {
		return m.MageCollateralized
	}
	return types.Coin{}
}

type PoolCollateral struct {
	// total collateral
	Collateral types.Coin `protobuf:"bytes,1,opt,name=collateral,proto3" json:"collateral"`
	// total existing war debt, including minted by collateral, mint fee, last
	// interest
	WarDebt types.Coin `protobuf:"bytes,2,opt,name=war_debt,json=warDebt,proto3" json:"war_debt"`
	// total collateralized mage
	MageCollateralized types.Coin `protobuf:"bytes,3,opt,name=mage_collateralized,json=mageCollateralized,proto3" json:"mage_collateralized"`
}

func (m *PoolCollateral) Reset()         { *m = PoolCollateral{} }
func (m *PoolCollateral) String() string { return proto.CompactTextString(m) }
func (*PoolCollateral) ProtoMessage()    {}
func (*PoolCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{14}
}
func (m *PoolCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolCollateral.Merge(m, src)
}
func (m *PoolCollateral) XXX_Size() int {
	return m.Size()
}
func (m *PoolCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_PoolCollateral proto.InternalMessageInfo

func (m *PoolCollateral) GetCollateral() types.Coin {
	if m != nil {
		return m.Collateral
	}
	return types.Coin{}
}

func (m *PoolCollateral) GetWarDebt() types.Coin {
	if m != nil {
		return m.WarDebt
	}
	return types.Coin{}
}

func (m *PoolCollateral) GetMageCollateralized() types.Coin {
	if m != nil {
		return m.MageCollateralized
	}
	return types.Coin{}
}

type AccountCollateral struct {
	// account who owns collateral
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// existing collateral
	Collateral types.Coin `protobuf:"bytes,2,opt,name=collateral,proto3" json:"collateral"`
	// remaining war debt, including minted by collateral, mint fee, last interest
	WarDebt types.Coin `protobuf:"bytes,3,opt,name=war_debt,json=warDebt,proto3" json:"war_debt"`
	// total collateralized mage
	MageCollateralized types.Coin `protobuf:"bytes,4,opt,name=mage_collateralized,json=mageCollateralized,proto3" json:"mage_collateralized"`
	// remaining interest debt at last settlement
	LastInterest types.Coin `protobuf:"bytes,5,opt,name=last_interest,json=lastInterest,proto3" json:"last_interest"`
	// the block of last settlement
	LastSettlementBlock int64 `protobuf:"varint,6,opt,name=last_settlement_block,json=lastSettlementBlock,proto3" json:"last_settlement_block,omitempty"`
}

func (m *AccountCollateral) Reset()         { *m = AccountCollateral{} }
func (m *AccountCollateral) String() string { return proto.CompactTextString(m) }
func (*AccountCollateral) ProtoMessage()    {}
func (*AccountCollateral) Descriptor() ([]byte, []int) {
	return fileDescriptor_894c2d78e9259b27, []int{15}
}
func (m *AccountCollateral) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountCollateral) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountCollateral.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountCollateral) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountCollateral.Merge(m, src)
}
func (m *AccountCollateral) XXX_Size() int {
	return m.Size()
}
func (m *AccountCollateral) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountCollateral.DiscardUnknown(m)
}

var xxx_messageInfo_AccountCollateral proto.InternalMessageInfo

func (m *AccountCollateral) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *AccountCollateral) GetCollateral() types.Coin {
	if m != nil {
		return m.Collateral
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetWarDebt() types.Coin {
	if m != nil {
		return m.WarDebt
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetMageCollateralized() types.Coin {
	if m != nil {
		return m.MageCollateralized
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetLastInterest() types.Coin {
	if m != nil {
		return m.LastInterest
	}
	return types.Coin{}
}

func (m *AccountCollateral) GetLastSettlementBlock() int64 {
	if m != nil {
		return m.LastSettlementBlock
	}
	return 0
}

func init() {
	proto.RegisterType((*BackingRiskParams)(nil), "warmage.maker.v1.BackingRiskParams")
	proto.RegisterType((*CollateralRiskParams)(nil), "warmage.maker.v1.CollateralRiskParams")
	proto.RegisterType((*RegisterBackingProposal)(nil), "warmage.maker.v1.RegisterBackingProposal")
	proto.RegisterType((*RegisterCollateralProposal)(nil), "warmage.maker.v1.RegisterCollateralProposal")
	proto.RegisterType((*SetBackingRiskParamsProposal)(nil), "warmage.maker.v1.SetBackingRiskParamsProposal")
	proto.RegisterType((*SetCollateralRiskParamsProposal)(nil), "warmage.maker.v1.SetCollateralRiskParamsProposal")
	proto.RegisterType((*BatchBackingRiskParams)(nil), "warmage.maker.v1.BatchBackingRiskParams")
	proto.RegisterType((*BatchSetBackingRiskParamsProposal)(nil), "warmage.maker.v1.BatchSetBackingRiskParamsProposal")
	proto.RegisterType((*BatchCollateralRiskParams)(nil), "warmage.maker.v1.BatchCollateralRiskParams")
	proto.RegisterType((*BatchSetCollateralRiskParamsProposal)(nil), "warmage.maker.v1.BatchSetCollateralRiskParamsProposal")
	proto.RegisterType((*TotalBacking)(nil), "warmage.maker.v1.TotalBacking")
	proto.RegisterType((*PoolBacking)(nil), "warmage.maker.v1.PoolBacking")
	proto.RegisterType((*AccountBacking)(nil), "warmage.maker.v1.AccountBacking")
	proto.RegisterType((*TotalCollateral)(nil), "warmage.maker.v1.TotalCollateral")
	proto.RegisterType((*PoolCollateral)(nil), "warmage.maker.v1.PoolCollateral")
	proto.RegisterType((*AccountCollateral)(nil), "warmage.maker.v1.AccountCollateral")
}

func init() { proto.RegisterFile("warmage/maker/v1/maker.proto", fileDescriptor_894c2d78e9259b27) }

var fileDescriptor_894c2d78e9259b27 = []byte{
	// 1034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0xc6, 0x6e, 0x1c, 0x3f, 0x3b, 0x3f, 0xba, 0x71, 0x8b, 0x1b, 0x55, 0x4e, 0x68, 0x51,
	0x55, 0x40, 0x5d, 0x2b, 0xe1, 0x44, 0x0f, 0xfc, 0x70, 0xd2, 0x4a, 0xa1, 0x35, 0x0a, 0xeb, 0x08,
	0x04, 0x42, 0x5a, 0xcd, 0xae, 0x1f, 0xce, 0xe0, 0xdd, 0x1d, 0x33, 0x3b, 0xce, 0x0f, 0xfe, 0x0a,
	0xae, 0xdc, 0x90, 0x10, 0x12, 0x1c, 0xe0, 0xc2, 0x3f, 0xd1, 0x63, 0x6e, 0x20, 0x0e, 0x15, 0x4a,
	0x84, 0x84, 0xc4, 0xbf, 0xc0, 0x01, 0xcd, 0xee, 0xac, 0xbd, 0x4e, 0x8c, 0xea, 0xb5, 0xad, 0x2a,
	0xa7, 0x78, 0xdf, 0xec, 0xf7, 0xe5, 0x7b, 0x6f, 0xde, 0x9b, 0xf9, 0x16, 0x6e, 0x1f, 0x11, 0xee,
	0x91, 0x36, 0xd6, 0x3c, 0xd2, 0x41, 0x5e, 0x3b, 0xdc, 0x8c, 0x7e, 0x18, 0x5d, 0xce, 0x04, 0xd3,
	0x57, 0xd4, 0xaa, 0x11, 0x05, 0x0f, 0x37, 0xd7, 0xca, 0x6d, 0xd6, 0x66, 0xe1, 0x62, 0x4d, 0xfe,
	0x8a, 0xde, 0x5b, 0xab, 0x3a, 0x2c, 0xf0, 0x58, 0x50, 0xb3, 0x49, 0x80, 0xb5, 0xc3, 0x4d, 0x1b,
	0x05, 0xd9, 0xac, 0x39, 0x8c, 0xfa, 0xd1, 0xfa, 0x9d, 0x6f, 0x73, 0x70, 0xbd, 0x4e, 0x9c, 0x0e,
	0xf5, 0xdb, 0x26, 0x0d, 0x3a, 0x7b, 0x84, 0x13, 0x2f, 0xd0, 0xef, 0xc2, 0xa2, 0x1d, 0x05, 0xad,
	0x16, 0xfa, 0xcc, 0xab, 0x68, 0x1b, 0xda, 0xfd, 0x82, 0x59, 0x52, 0xc1, 0x1d, 0x19, 0xd3, 0x2b,
	0x90, 0x47, 0x9f, 0xd8, 0x2e, 0xb6, 0x2a, 0x73, 0x1b, 0xda, 0xfd, 0x05, 0x33, 0x7e, 0xd4, 0x9f,
	0x40, 0xd1, 0x23, 0xc7, 0x96, 0x7a, 0xbb, 0x92, 0x95, 0xe0, 0xfa, 0x1b, 0x7f, 0x3c, 0x5f, 0xbf,
	0xd7, 0xa6, 0xe2, 0xa0, 0x67, 0x1b, 0x0e, 0xf3, 0x6a, 0x4a, 0x58, 0xf4, 0xe7, 0x41, 0xd0, 0xea,
	0xd4, 0xc4, 0x49, 0x17, 0x03, 0x63, 0xd7, 0x17, 0x26, 0x78, 0xe4, 0x58, 0xa9, 0xd2, 0x9f, 0x42,
	0x49, 0x92, 0x1d, 0x11, 0x6e, 0x79, 0xd4, 0x17, 0x95, 0xdc, 0x44, 0x6c, 0x9f, 0x10, 0xde, 0xa0,
	0xbe, 0xd0, 0x1f, 0xc1, 0x82, 0x64, 0xb1, 0xbe, 0x40, 0xac, 0x5c, 0x4b, 0xc5, 0xb4, 0x83, 0x8e,
	0x99, 0x97, 0xd8, 0xc7, 0x88, 0x92, 0xc6, 0xee, 0x71, 0x3f, 0xa4, 0x99, 0x4f, 0x4f, 0x23, 0xb1,
	0x92, 0xe6, 0x09, 0x14, 0xed, 0xde, 0x89, 0xac, 0x53, 0xc8, 0x94, 0x4f, 0xcd, 0x04, 0x0a, 0x2e,
	0xc9, 0x76, 0x01, 0x38, 0xf6, 0xb9, 0x16, 0x52, 0x73, 0x15, 0x22, 0xf4, 0x63, 0xc4, 0x87, 0xb9,
	0xbf, 0xbf, 0x5b, 0xcf, 0xdc, 0xf9, 0x6d, 0x1e, 0xca, 0xdb, 0xcc, 0x75, 0x89, 0x40, 0x4e, 0xdc,
	0x44, 0x7b, 0xbc, 0x0e, 0x2b, 0x4e, 0x3f, 0x3e, 0xd4, 0x21, 0xcb, 0x83, 0xf8, 0x8b, 0x9a, 0xe4,
	0x23, 0x58, 0x92, 0xfb, 0x3a, 0x00, 0x4c, 0xd0, 0x27, 0x8b, 0x1e, 0x39, 0x1e, 0x28, 0x9c, 0x71,
	0xab, 0x58, 0x70, 0xc3, 0xa5, 0x5f, 0xf5, 0x68, 0x8b, 0x08, 0xca, 0x7c, 0x4b, 0x1c, 0x70, 0x0c,
	0x0e, 0x98, 0xdb, 0x9a, 0xa0, 0x6f, 0xca, 0x09, 0xa2, 0xfd, 0x98, 0x47, 0xff, 0x10, 0x16, 0x5d,
	0x46, 0x7c, 0x4b, 0x30, 0xeb, 0x90, 0xb8, 0xbd, 0x49, 0x3a, 0xa9, 0x28, 0x09, 0xf6, 0xd9, 0xc7,
	0x12, 0xae, 0x7f, 0x0a, 0xab, 0x36, 0x09, 0xa8, 0x63, 0x0d, 0xb3, 0xa6, 0xef, 0xaa, 0x95, 0x90,
	0xe6, 0x69, 0x82, 0xfa, 0x73, 0x28, 0x3b, 0x44, 0x10, 0xf7, 0x44, 0x50, 0xc7, 0x92, 0xe7, 0x8e,
	0xc5, 0x65, 0x32, 0x13, 0x74, 0x99, 0xde, 0xe7, 0x69, 0x90, 0x36, 0x9a, 0x92, 0x45, 0x6f, 0xc2,
	0x72, 0xb2, 0xd2, 0xb2, 0x7d, 0x0b, 0xa9, 0x89, 0x97, 0x12, 0x14, 0x6a, 0x44, 0xfb, 0x93, 0x0e,
	0x93, 0x4f, 0x7a, 0x03, 0x4a, 0xd4, 0x17, 0xc8, 0x31, 0x88, 0xa8, 0x8a, 0xe9, 0xf7, 0x28, 0xc6,
	0x0f, 0x26, 0xeb, 0x7b, 0x0d, 0x5e, 0x31, 0xb1, 0x4d, 0x03, 0x81, 0x5c, 0x9d, 0x73, 0x7b, 0x9c,
	0x75, 0x59, 0x40, 0x5c, 0xbd, 0x0c, 0xd7, 0x04, 0x15, 0x2e, 0xaa, 0x89, 0x8a, 0x1e, 0xf4, 0x0d,
	0x28, 0xb6, 0x30, 0x70, 0x38, 0xed, 0xca, 0xfc, 0xc2, 0x59, 0x2a, 0x98, 0xc9, 0x90, 0xfe, 0x01,
	0x14, 0x39, 0x0d, 0x3a, 0x56, 0x37, 0x9c, 0xd1, 0x70, 0x98, 0x8a, 0x5b, 0x77, 0x8d, 0x8b, 0xf7,
	0x84, 0x71, 0xe9, 0xb4, 0xaf, 0xe7, 0x9e, 0x3d, 0x5f, 0xcf, 0x98, 0xc0, 0xfb, 0x11, 0xa5, 0xf2,
	0x27, 0x0d, 0xd6, 0x62, 0x95, 0x83, 0x29, 0x9b, 0x5a, 0x68, 0x63, 0x94, 0xd0, 0x7b, 0x97, 0x85,
	0x8e, 0x3a, 0x7a, 0xfe, 0x57, 0xeb, 0x8f, 0x1a, 0xdc, 0x6e, 0xa2, 0xb8, 0x94, 0xdc, 0x15, 0x2c,
	0xeb, 0x2f, 0x1a, 0xac, 0x37, 0x51, 0x8c, 0x4a, 0xef, 0x6a, 0xd6, 0xf6, 0x4b, 0xb8, 0x59, 0x27,
	0xc2, 0x39, 0xb8, 0xec, 0x13, 0x2e, 0x14, 0x47, 0xdb, 0xc8, 0x4e, 0x5b, 0x9c, 0x9f, 0x35, 0x78,
	0x35, 0xfc, 0x67, 0x2f, 0x67, 0x33, 0xa7, 0xd6, 0xdb, 0x85, 0x5b, 0xa1, 0xdc, 0x91, 0xf7, 0x64,
	0x63, 0x54, 0x79, 0xa6, 0xdd, 0x8d, 0x5f, 0x35, 0x78, 0x2d, 0xae, 0xd0, 0xcb, 0xe9, 0xa1, 0x59,
	0xa8, 0xfe, 0x47, 0x83, 0xd2, 0x3e, 0x13, 0xc4, 0x8d, 0x6d, 0x5d, 0x73, 0x60, 0x31, 0xa3, 0x6b,
	0x2a, 0x54, 0x59, 0x37, 0x24, 0x3e, 0xc5, 0x85, 0x1d, 0x5b, 0xd2, 0xe8, 0x9a, 0x7a, 0x07, 0x20,
	0xbe, 0xfc, 0x95, 0xe1, 0x28, 0x6e, 0xdd, 0x32, 0x22, 0xa0, 0x21, 0x2d, 0xb0, 0xa1, 0x2c, 0xb0,
	0xb1, 0xcd, 0xa8, 0xaf, 0xc4, 0x16, 0x8e, 0xa2, 0x0b, 0x1f, 0x5b, 0xfa, 0x7b, 0xd2, 0xb8, 0xb6,
	0xd1, 0x92, 0xfe, 0x0c, 0x5b, 0x6a, 0x7c, 0x5e, 0x48, 0x00, 0x12, 0x53, 0x0f, 0x21, 0x2a, 0xdb,
	0x53, 0x0d, 0x8a, 0x7b, 0x8c, 0xf5, 0x93, 0x1d, 0xd6, 0xa5, 0xa5, 0xd6, 0xf5, 0x36, 0xe4, 0x63,
	0x33, 0x3d, 0x66, 0x52, 0xf1, 0xfb, 0x33, 0x4b, 0xe9, 0x26, 0x2c, 0xbd, 0xef, 0x38, 0xac, 0xe7,
	0xc7, 0x63, 0xa9, 0xe2, 0x3f, 0x68, 0xb0, 0x1c, 0x6e, 0x6c, 0xc2, 0x87, 0x3d, 0x84, 0x05, 0x99,
	0x6e, 0x0b, 0x6d, 0x31, 0x6e, 0xb2, 0xf9, 0x23, 0xc2, 0x77, 0xd0, 0x16, 0xfa, 0x1e, 0xac, 0x86,
	0x7a, 0x07, 0xbe, 0x90, 0x7e, 0x3d, 0xfe, 0x5e, 0xea, 0x12, 0xbb, 0x3d, 0x04, 0x55, 0x3a, 0xff,
	0xd2, 0x60, 0x49, 0x6e, 0x49, 0x42, 0xe6, 0xbb, 0x00, 0x09, 0xf7, 0x39, 0xa6, 0xd0, 0x04, 0x64,
	0x28, 0xcf, 0xb9, 0xd9, 0xe4, 0x99, 0x9d, 0x36, 0xcf, 0x7f, 0xe7, 0xe0, 0xba, 0xda, 0xa8, 0x44,
	0xaa, 0x15, 0xc8, 0x93, 0x28, 0xa8, 0x4e, 0x83, 0xf8, 0xf1, 0x42, 0x11, 0xe6, 0xa6, 0x2b, 0x42,
	0x76, 0x36, 0x45, 0xc8, 0x4d, 0x5c, 0x04, 0x7d, 0x07, 0x16, 0x5d, 0x12, 0x08, 0x2b, 0xf6, 0x5c,
	0xa1, 0x59, 0x1f, 0x83, 0xab, 0x24, 0x51, 0xbb, 0x0a, 0xa4, 0x6f, 0xc1, 0x8d, 0x90, 0x25, 0x40,
	0x21, 0x5c, 0xf4, 0xd0, 0x17, 0x96, 0xed, 0x32, 0xa7, 0x13, 0x3a, 0xf4, 0xac, 0xb9, 0x2a, 0x17,
	0x9b, 0xfd, 0xb5, 0xba, 0x5c, 0x8a, 0xca, 0x5f, 0x7f, 0xf4, 0xec, 0xac, 0xaa, 0x9d, 0x9e, 0x55,
	0xb5, 0x3f, 0xcf, 0xaa, 0xda, 0x37, 0xe7, 0xd5, 0xcc, 0xe9, 0x79, 0x35, 0xf3, 0xfb, 0x79, 0x35,
	0xf3, 0xd9, 0x9b, 0x89, 0x13, 0xad, 0x8b, 0x82, 0xd3, 0x07, 0x2e, 0xb1, 0x83, 0x5a, 0xfc, 0x95,
	0x7f, 0xac, 0xbe, 0xf3, 0xc3, 0xa3, 0xcd, 0x9e, 0x0f, 0xbf, 0xce, 0xdf, 0xfa, 0x2f, 0x00, 0x00,
	0xff, 0xff, 0xe4, 0x22, 0x5f, 0xca, 0x05, 0x10, 0x00, 0x00,
}

func (m *BackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RebackFee != nil {
		{
			size := m.RebackFee.Size()
			i -= size
			if _, err := m.RebackFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BuybackFee != nil {
		{
			size := m.BuybackFee.Size()
			i -= size
			if _, err := m.BuybackFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BurnFee != nil {
		{
			size := m.BurnFee.Size()
			i -= size
			if _, err := m.BurnFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxWarMint != nil {
		{
			size := m.MaxWarMint.Size()
			i -= size
			if _, err := m.MaxWarMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxBacking != nil {
		{
			size := m.MaxBacking.Size()
			i -= size
			if _, err := m.MaxBacking.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.BackingDenom) > 0 {
		i -= len(m.BackingDenom)
		copy(dAtA[i:], m.BackingDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.BackingDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterestFee != nil {
		{
			size := m.InterestFee.Size()
			i -= size
			if _, err := m.InterestFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.MintFee != nil {
		{
			size := m.MintFee.Size()
			i -= size
			if _, err := m.MintFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.LiquidationFee != nil {
		{
			size := m.LiquidationFee.Size()
			i -= size
			if _, err := m.LiquidationFee.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CatalyticMageRatio != nil {
		{
			size := m.CatalyticMageRatio.Size()
			i -= size
			if _, err := m.CatalyticMageRatio.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.BasicLoanToValue != nil {
		{
			size := m.BasicLoanToValue.Size()
			i -= size
			if _, err := m.BasicLoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.LoanToValue != nil {
		{
			size := m.LoanToValue.Size()
			i -= size
			if _, err := m.LoanToValue.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.LiquidationThreshold != nil {
		{
			size := m.LiquidationThreshold.Size()
			i -= size
			if _, err := m.LiquidationThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxWarMint != nil {
		{
			size := m.MaxWarMint.Size()
			i -= size
			if _, err := m.MaxWarMint.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.MaxCollateral != nil {
		{
			size := m.MaxCollateral.Size()
			i -= size
			if _, err := m.MaxCollateral.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintMaker(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CollateralDenom) > 0 {
		i -= len(m.CollateralDenom)
		copy(dAtA[i:], m.CollateralDenom)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.CollateralDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterBackingProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterBackingProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterBackingProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterCollateralProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterCollateralProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterCollateralProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetBackingRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBackingRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetBackingRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetCollateralRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetCollateralRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetCollateralRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.RiskParams.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchBackingRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchBackingRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchBackingRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetBackingRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetBackingRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetBackingRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchCollateralRiskParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchCollateralRiskParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchCollateralRiskParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchSetCollateralRiskParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSetCollateralRiskParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSetCollateralRiskParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for iNdEx := len(m.RiskParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RiskParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMaker(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TotalBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MageBurned.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.WarMinted.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.BackingValue.Size()
		i -= size
		if _, err := m.BackingValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MageBurned.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Backing.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.WarMinted.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AccountBacking) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountBacking) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountBacking) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TotalCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TotalCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TotalCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MageCollateralized.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.WarDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PoolCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MageCollateralized.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.WarDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AccountCollateral) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountCollateral) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountCollateral) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSettlementBlock != 0 {
		i = encodeVarintMaker(dAtA, i, uint64(m.LastSettlementBlock))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.LastInterest.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.MageCollateralized.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.WarDebt.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Collateral.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMaker(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintMaker(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMaker(dAtA []byte, offset int, v uint64) int {
	offset -= sovMaker(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BackingDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxBacking != nil {
		l = m.MaxBacking.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxWarMint != nil {
		l = m.MaxWarMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BurnFee != nil {
		l = m.BurnFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BuybackFee != nil {
		l = m.BuybackFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.RebackFee != nil {
		l = m.RebackFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *CollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CollateralDenom)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.MaxCollateral != nil {
		l = m.MaxCollateral.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MaxWarMint != nil {
		l = m.MaxWarMint.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationThreshold != nil {
		l = m.LiquidationThreshold.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LoanToValue != nil {
		l = m.LoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.BasicLoanToValue != nil {
		l = m.BasicLoanToValue.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.CatalyticMageRatio != nil {
		l = m.CatalyticMageRatio.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.LiquidationFee != nil {
		l = m.LiquidationFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.MintFee != nil {
		l = m.MintFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	if m.InterestFee != nil {
		l = m.InterestFee.Size()
		n += 1 + l + sovMaker(uint64(l))
	}
	return n
}

func (m *RegisterBackingProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *RegisterCollateralProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *SetBackingRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *SetCollateralRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.RiskParams.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *BatchBackingRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchSetBackingRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchCollateralRiskParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *BatchSetCollateralRiskParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	if len(m.RiskParams) > 0 {
		for _, e := range m.RiskParams {
			l = e.Size()
			n += 1 + l + sovMaker(uint64(l))
		}
	}
	return n
}

func (m *TotalBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.BackingValue.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.WarMinted.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MageBurned.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *PoolBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.WarMinted.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.Backing.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MageBurned.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *AccountBacking) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TotalCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.WarDebt.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MageCollateralized.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *PoolCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Collateral.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.WarDebt.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MageCollateralized.Size()
	n += 1 + l + sovMaker(uint64(l))
	return n
}

func (m *AccountCollateral) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovMaker(uint64(l))
	}
	l = m.Collateral.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.WarDebt.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.MageCollateralized.Size()
	n += 1 + l + sovMaker(uint64(l))
	l = m.LastInterest.Size()
	n += 1 + l + sovMaker(uint64(l))
	if m.LastSettlementBlock != 0 {
		n += 1 + sovMaker(uint64(m.LastSettlementBlock))
	}
	return n
}

func sovMaker(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMaker(x uint64) (n int) {
	return sovMaker(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackingDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBacking", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxBacking = &v
			if err := m.MaxBacking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWarMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxWarMint = &v
			if err := m.MaxWarMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BurnFee = &v
			if err := m.BurnFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuybackFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BuybackFee = &v
			if err := m.BuybackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebackFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.RebackFee = &v
			if err := m.RebackFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollateralDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollateralDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCollateral", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxCollateral = &v
			if err := m.MaxCollateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWarMint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Int
			m.MaxWarMint = &v
			if err := m.MaxWarMint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationThreshold = &v
			if err := m.LiquidationThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LoanToValue = &v
			if err := m.LoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicLoanToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.BasicLoanToValue = &v
			if err := m.BasicLoanToValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatalyticMageRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.CatalyticMageRatio = &v
			if err := m.CatalyticMageRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.LiquidationFee = &v
			if err := m.LiquidationFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.MintFee = &v
			if err := m.MintFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.InterestFee = &v
			if err := m.InterestFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterBackingProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterBackingProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterBackingProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterCollateralProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterCollateralProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterCollateralProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBackingRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBackingRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBackingRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetCollateralRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetCollateralRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetCollateralRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RiskParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchBackingRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchBackingRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchBackingRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, BackingRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetBackingRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetBackingRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetBackingRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, BackingRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchCollateralRiskParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchCollateralRiskParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchCollateralRiskParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, CollateralRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSetCollateralRiskParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSetCollateralRiskParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiskParams = append(m.RiskParams, CollateralRiskParams{})
			if err := m.RiskParams[len(m.RiskParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackingValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BackingValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarMinted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WarMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MageBurned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MageBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarMinted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WarMinted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Backing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MageBurned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MageBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountBacking) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountBacking: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountBacking: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TotalCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TotalCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TotalCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WarDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MageCollateralized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MageCollateralized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WarDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MageCollateralized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MageCollateralized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountCollateral) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountCollateral: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountCollateral: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collateral", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Collateral.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarDebt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WarDebt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MageCollateralized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MageCollateralized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastInterest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMaker
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMaker
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastInterest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSettlementBlock", wireType)
			}
			m.LastSettlementBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSettlementBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMaker(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMaker
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMaker(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMaker
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMaker
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMaker
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMaker
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMaker
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMaker        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMaker          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMaker = fmt.Errorf("proto: unexpected end of group")
)
